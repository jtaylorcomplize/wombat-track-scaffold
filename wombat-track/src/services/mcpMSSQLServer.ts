/**
 * MCP MSSQL Server - OF-8.6 Implementation
 * Canonical cloud database integration with event-driven PhaseStep creation
 */

import { EventEmitter } from 'events';
import { enhancedGovernanceLogger } from './enhancedGovernanceLogger';
import { azureIdentityService } from './azureIdentityService';

export interface MCPResource {
  uri: string;
  name: string;
  description: string;
  mimeType: string;
  data?: any;
}

export interface MCPTool {
  name: string;
  description: string;
  inputSchema: any;
  handler: (args: any) => Promise<any>;
}

export interface GovernanceEvent {
  eventId: string;
  timestamp: string;
  eventType: string;
  projectId: string;
  phaseId?: string;
  stepId?: string;
  data: Record<string, any>;
  memoryAnchor?: string;
  source: string;
}

export interface PhaseStep {
  id: string;
  projectId: string;
  phaseId: string;
  stepName: string;
  description: string;
  status: 'not_started' | 'in_progress' | 'completed' | 'blocked' | 'cancelled';
  progress: number;
  priority: 'low' | 'medium' | 'high' | 'critical';
  assignedTo?: string;
  dueDate?: string;
  createdAt: string;
  updatedAt: string;
  governanceEventId?: string;
  autoGenerated: boolean;
  memoryAnchorRefs: string[];
}

class MCPMSSQLServer extends EventEmitter {
  private initialized = false;
  private connectionPool: any = null;
  private resources: Map<string, MCPResource> = new Map();
  private tools: Map<string, MCPTool> = new Map();
  private config: any = null;

  async initialize(): Promise<void> {
    if (this.initialized) return;

    console.log('üöÄ Initializing MCP MSSQL Server...');

    // Load configuration
    await this.loadConfiguration();
    
    // Initialize Azure Identity Service
    await azureIdentityService.initialize();
    
    // Setup database connection
    await this.setupDatabaseConnection();
    
    // Register MCP resources
    await this.registerResources();
    
    // Register MCP tools
    await this.registerTools();
    
    // Setup event listeners
    this.setupEventListeners();
    
    this.initialized = true;
    console.log('‚úÖ MCP MSSQL Server initialized successfully');
    
    // Create initialization governance log
    enhancedGovernanceLogger.createPhaseAnchor('mcp-mssql-server-init', 'infrastructure');
  }

  private async loadConfiguration(): Promise<void> {
    // Load configuration from file or environment
    this.config = {
      server: {
        port: process.env.PORT || 8002,
        host: process.env.HOST || '0.0.0.0'
      },
      database: {
        server: process.env.AZURE_SQL_SERVER,
        database: process.env.AZURE_SQL_DATABASE,
        connectionString: await azureIdentityService.getSecret('database-connection-string') || process.env.AZURE_SQL_CONNECTION_STRING,
        pool: {
          min: parseInt(process.env.DB_POOL_MIN || '2'),
          max: parseInt(process.env.DB_POOL_MAX || '20'),
          idleTimeoutMillis: parseInt(process.env.DB_IDLE_TIMEOUT || '30000'),
          requestTimeout: parseInt(process.env.DB_REQUEST_TIMEOUT || '30000')
        }
      },
      compliance: {
        dataResidency: 'australia_east',
        auditLogging: process.env.AUDIT_LOGGING === 'enabled',
        encryption: {
          inTransit: true,
          atRest: true
        }
      },
      features: {
        governanceSync: process.env.ENABLE_GOVERNANCE_SYNC === 'true',
        autoPhaseStepCreation: process.env.ENABLE_PHASE_STEP_AUTO_CREATION === 'true',
        memoryAnchorLinking: process.env.ENABLE_MEMORY_ANCHOR_LINKING === 'true'
      }
    };

    console.log('üìã Configuration loaded with AU compliance settings');
  }

  private async setupDatabaseConnection(): Promise<void> {
    try {
      console.log('üîó Setting up Azure SQL Database connection...');
      
      // In production, use actual MSSQL connection pool
      // For now, simulate connection setup
      
      this.connectionPool = {
        connected: true,
        database: this.config.database.database,
        server: this.config.database.server,
        auCompliant: true
      };

      console.log('‚úÖ Database connection established with AU compliance');
    } catch (error) {
      console.error('‚ùå Database connection failed:', error);
      throw error;
    }
  }

  private async registerResources(): Promise<void> {
    const resources: MCPResource[] = [
      {
        uri: 'mssql://projects',
        name: 'Projects',
        description: 'Canonical project records from Azure SQL',
        mimeType: 'application/json'
      },
      {
        uri: 'mssql://phases',
        name: 'Phases', 
        description: 'Project phase records from Azure SQL',
        mimeType: 'application/json'
      },
      {
        uri: 'mssql://phase_steps',
        name: 'PhaseSteps',
        description: 'Individual phase step records from Azure SQL',
        mimeType: 'application/json'
      },
      {
        uri: 'mssql://governance_logs',
        name: 'GovernanceLogs',
        description: 'Governance event logs from Azure SQL',
        mimeType: 'application/json'
      },
      {
        uri: 'mssql://memory_anchors',
        name: 'MemoryAnchors',
        description: 'Memory anchor references from Azure SQL',
        mimeType: 'application/json'
      }
    ];

    resources.forEach(resource => {
      this.resources.set(resource.uri, resource);
    });

    console.log(`üìö Registered ${resources.length} MCP resources`);
  }

  private async registerTools(): Promise<void> {
    // Create PhaseStep Tool
    this.tools.set('create_phase_step', {
      name: 'create_phase_step',
      description: 'Create new PhaseStep from governance event',
      inputSchema: {
        type: 'object',
        properties: {
          projectId: { type: 'string' },
          phaseId: { type: 'string' },
          stepName: { type: 'string' },
          description: { type: 'string' },
          governanceEventId: { type: 'string' },
          priority: { type: 'string', enum: ['low', 'medium', 'high', 'critical'] },
          assignedTo: { type: 'string' },
          dueDate: { type: 'string', format: 'date-time' }
        },
        required: ['projectId', 'phaseId', 'stepName', 'governanceEventId']
      },
      handler: this.createPhaseStep.bind(this)
    });

    // Update Step Progress Tool
    this.tools.set('update_step_progress', {
      name: 'update_step_progress',
      description: 'Update PhaseStep progress and sync governance',
      inputSchema: {
        type: 'object',
        properties: {
          stepId: { type: 'string' },
          progress: { type: 'number', minimum: 0, maximum: 100 },
          status: { type: 'string', enum: ['not_started', 'in_progress', 'completed', 'blocked', 'cancelled'] },
          notes: { type: 'string' },
          completedBy: { type: 'string' }
        },
        required: ['stepId', 'progress', 'status']
      },
      handler: this.updateStepProgress.bind(this)
    });

    // Governance Sync Tool
    this.tools.set('sync_governance_events', {
      name: 'sync_governance_events',
      description: 'Sync governance events to canonical database',
      inputSchema: {
        type: 'object',
        properties: {
          events: {
            type: 'array',
            items: {
              type: 'object',
              properties: {
                eventId: { type: 'string' },
                timestamp: { type: 'string', format: 'date-time' },
                eventType: { type: 'string' },
                projectId: { type: 'string' },
                phaseId: { type: 'string' },
                data: { type: 'object' },
                memoryAnchor: { type: 'string' }
              }
            }
          }
        },
        required: ['events']
      },
      handler: this.syncGovernanceEvents.bind(this)
    });

    // Query Tool
    this.tools.set('query_canonical_data', {
      name: 'query_canonical_data',
      description: 'Query canonical database with SQL',
      inputSchema: {
        type: 'object',
        properties: {
          query: { type: 'string' },
          parameters: { type: 'object' },
          timeout: { type: 'number', default: 30000 }
        },
        required: ['query']
      },
      handler: this.queryCanonicalData.bind(this)
    });

    // Memory Anchor Tool
    this.tools.set('create_memory_anchor', {
      name: 'create_memory_anchor',
      description: 'Create memory anchor with canonical DB reference',
      inputSchema: {
        type: 'object',
        properties: {
          anchorId: { type: 'string' },
          projectId: { type: 'string' },
          phaseId: { type: 'string' },
          stepId: { type: 'string' },
          anchorType: { type: 'string' },
          content: { type: 'object' },
          tags: { type: 'array', items: { type: 'string' } }
        },
        required: ['anchorId', 'projectId', 'anchorType', 'content']
      },
      handler: this.createMemoryAnchor.bind(this)
    });

    console.log(`üîß Registered ${this.tools.size} MCP tools`);
  }

  private setupEventListeners(): void {
    // Listen for governance events from other services
    this.on('governance_event', this.handleGovernanceEvent.bind(this));
    this.on('phase_step_update', this.handlePhaseStepUpdate.bind(this));
    this.on('memory_anchor_created', this.handleMemoryAnchorCreated.bind(this));

    console.log('üì° Event listeners configured');
  }

  // MCP Tool Handlers

  private async createPhaseStep(args: any): Promise<PhaseStep> {
    console.log('üéØ Creating PhaseStep from governance event:', args.governanceEventId);

    const phaseStep: PhaseStep = {
      id: `step_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      projectId: args.projectId,
      phaseId: args.phaseId,
      stepName: args.stepName,
      description: args.description || `Auto-generated from governance event ${args.governanceEventId}`,
      status: 'not_started',
      progress: 0,
      priority: args.priority || 'medium',
      assignedTo: args.assignedTo,
      dueDate: args.dueDate,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      governanceEventId: args.governanceEventId,
      autoGenerated: true,
      memoryAnchorRefs: []
    };

    // Insert into database (simulated)
    await this.insertPhaseStepToDatabase(phaseStep);

    // Emit event for other services
    this.emit('phase_step_auto_created', phaseStep);

    // Create governance log entry
    enhancedGovernanceLogger.createPhaseAnchor(
      `phase-step-auto-created-${phaseStep.id}`,
      'automation'
    );

    console.log(`‚úÖ PhaseStep created: ${phaseStep.id}`);
    return phaseStep;
  }

  private async updateStepProgress(args: any): Promise<{ success: boolean; updated: PhaseStep }> {
    console.log('üìä Updating PhaseStep progress:', args.stepId);

    // Simulate database update
    const updatedStep: PhaseStep = {
      id: args.stepId,
      projectId: 'mock-project',
      phaseId: 'mock-phase',
      stepName: 'Mock Step',
      description: 'Mock step description',
      status: args.status,
      progress: args.progress,
      priority: 'medium',
      createdAt: '2025-01-01T00:00:00Z',
      updatedAt: new Date().toISOString(),
      autoGenerated: false,
      memoryAnchorRefs: []
    };

    // Update in database (simulated)
    await this.updatePhaseStepInDatabase(updatedStep);

    // Create governance event for progress update
    const governanceEvent: GovernanceEvent = {
      eventId: `progress_update_${Date.now()}`,
      timestamp: new Date().toISOString(),
      eventType: 'phase_step_progress_updated',
      projectId: updatedStep.projectId,
      phaseId: updatedStep.phaseId,
      stepId: updatedStep.id,
      data: {
        previousProgress: 0, // Would fetch from DB
        newProgress: args.progress,
        status: args.status,
        notes: args.notes,
        completedBy: args.completedBy
      },
      source: 'mcp-mssql-server'
    };

    // Sync governance event
    await this.syncGovernanceEvents({ events: [governanceEvent] });

    // Emit event
    this.emit('phase_step_updated', updatedStep);

    console.log(`‚úÖ PhaseStep progress updated: ${args.stepId} -> ${args.progress}%`);
    return { success: true, updated: updatedStep };
  }

  private async syncGovernanceEvents(args: { events: GovernanceEvent[] }): Promise<{ synced: number; failed: number }> {
    console.log(`üîÑ Syncing ${args.events.length} governance events to canonical DB`);

    let synced = 0;
    let failed = 0;

    for (const event of args.events) {
      try {
        // Insert into governance_logs table (simulated)
        await this.insertGovernanceEventToDatabase(event);
        
        // Check if event should trigger PhaseStep creation
        if (this.config.features.autoPhaseStepCreation && this.shouldCreatePhaseStep(event)) {
          await this.autoCreatePhaseStepFromEvent(event);
        }

        synced++;
      } catch (error) {
        console.error(`Failed to sync event ${event.eventId}:`, error);
        failed++;
      }
    }

    // Emit sync completed event
    this.emit('governance_sync_completed', { synced, failed, total: args.events.length });

    console.log(`‚úÖ Governance sync completed: ${synced} synced, ${failed} failed`);
    return { synced, failed };
  }

  private async queryCanonicalData(args: { query: string; parameters?: any; timeout?: number }): Promise<any[]> {
    console.log('üîç Querying canonical database:', args.query.substring(0, 100) + '...');

    // Validate query for security
    if (!this.isQuerySafe(args.query)) {
      throw new Error('Query validation failed: potentially unsafe SQL detected');
    }

    // Execute query (simulated)
    const mockResults = [
      {
        id: '1',
        projectId: 'OF-8.6',
        name: 'Azure OpenAI & MCP Integration',
        status: 'active',
        createdAt: '2025-08-05T00:00:00Z'
      }
    ];

    // Log query execution for audit
    if (this.config.compliance.auditLogging) {
      await this.logQueryExecution(args.query, mockResults.length);
    }

    console.log(`‚úÖ Query executed, returned ${mockResults.length} rows`);
    return mockResults;
  }

  private async createMemoryAnchor(args: any): Promise<{ anchorId: string; created: boolean }> {
    console.log('‚öì Creating memory anchor:', args.anchorId);

    // Insert memory anchor into database (simulated)
    const memoryAnchor = {
      id: args.anchorId,
      projectId: args.projectId,
      phaseId: args.phaseId,
      stepId: args.stepId,
      anchorType: args.anchorType,
      content: args.content,
      tags: args.tags || [],
      createdAt: new Date().toISOString(),
      auCompliant: true
    };

    await this.insertMemoryAnchorToDatabase(memoryAnchor);

    // Link to PhaseStep if provided
    if (args.stepId && this.config.features.memoryAnchorLinking) {
      await this.linkMemoryAnchorToPhaseStep(args.stepId, args.anchorId);
    }

    // Emit event
    this.emit('memory_anchor_created', memoryAnchor);

    console.log(`‚úÖ Memory anchor created: ${args.anchorId}`);
    return { anchorId: args.anchorId, created: true };
  }

  // Event Handlers

  private async handleGovernanceEvent(event: GovernanceEvent): Promise<void> {
    console.log('üì• Handling governance event:', event.eventType);

    if (this.config.features.governanceSync) {
      await this.syncGovernanceEvents({ events: [event] });
    }
  }

  private async handlePhaseStepUpdate(step: PhaseStep): Promise<void> {
    console.log('üìù Handling PhaseStep update:', step.id);

    // Update related memory anchors
    if (this.config.features.memoryAnchorLinking) {
      await this.updateMemoryAnchorReferences(step);
    }
  }

  private async handleMemoryAnchorCreated(anchor: any): Promise<void> {
    console.log('‚öì Handling memory anchor creation:', anchor.id);

    // Link to related governance events
    await this.linkMemoryAnchorToGovernanceEvents(anchor);
  }

  // Database Operations (Simulated)

  private async insertPhaseStepToDatabase(phaseStep: PhaseStep): Promise<void> {
    // Simulate database insert
    console.log(`üíæ Inserting PhaseStep to Azure SQL: ${phaseStep.id}`);
    await new Promise(resolve => setTimeout(resolve, 100));
  }

  private async updatePhaseStepInDatabase(phaseStep: PhaseStep): Promise<void> {
    // Simulate database update
    console.log(`üíæ Updating PhaseStep in Azure SQL: ${phaseStep.id}`);
    await new Promise(resolve => setTimeout(resolve, 100));
  }

  private async insertGovernanceEventToDatabase(event: GovernanceEvent): Promise<void> {
    // Simulate database insert
    console.log(`üíæ Inserting governance event to Azure SQL: ${event.eventId}`);
    await new Promise(resolve => setTimeout(resolve, 50));
  }

  private async insertMemoryAnchorToDatabase(anchor: any): Promise<void> {
    // Simulate database insert
    console.log(`üíæ Inserting memory anchor to Azure SQL: ${anchor.id}`);
    await new Promise(resolve => setTimeout(resolve, 50));
  }

  // Utility Methods

  private shouldCreatePhaseStep(event: GovernanceEvent): boolean {
    const autoCreateEventTypes = [
      'work_surface_navigation',
      'project_phase_started',
      'governance_checkpoint_reached',
      'memory_anchor_created'
    ];

    return autoCreateEventTypes.includes(event.eventType);
  }

  private async autoCreatePhaseStepFromEvent(event: GovernanceEvent): Promise<void> {
    if (!event.projectId || !event.phaseId) return;

    const stepName = `Auto: ${event.eventType.replace(/_/g, ' ')}`;
    const description = `Automatically created PhaseStep for governance event: ${event.eventId}`;

    await this.createPhaseStep({
      projectId: event.projectId,
      phaseId: event.phaseId,
      stepName,
      description,
      governanceEventId: event.eventId,
      priority: 'medium'
    });
  }

  private isQuerySafe(query: string): boolean {
    // Basic SQL injection prevention
    const dangerousPatterns = [
      /DROP\s+TABLE/i,
      /DELETE\s+FROM/i,
      /INSERT\s+INTO/i,
      /UPDATE\s+.*SET/i,
      /ALTER\s+TABLE/i,
      /CREATE\s+TABLE/i,
      /TRUNCATE/i,
      /EXEC/i,
      /EXECUTE/i
    ];

    return !dangerousPatterns.some(pattern => pattern.test(query));
  }

  private async logQueryExecution(query: string, resultCount: number): Promise<void> {
    const auditEntry = {
      timestamp: new Date().toISOString(),
      operation: 'query_execution',
      query: query.substring(0, 200) + (query.length > 200 ? '...' : ''),
      resultCount,
      source: 'mcp-mssql-server',
      compliance: 'AU-resident'
    };

    console.log('üîç Query audit:', JSON.stringify(auditEntry));
  }

  private async linkMemoryAnchorToPhaseStep(stepId: string, anchorId: string): Promise<void> {
    console.log(`üîó Linking memory anchor ${anchorId} to PhaseStep ${stepId}`);
    // Simulate database update
    await new Promise(resolve => setTimeout(resolve, 50));
  }

  private async updateMemoryAnchorReferences(step: PhaseStep): Promise<void> {
    console.log(`üîÑ Updating memory anchor references for PhaseStep ${step.id}`);
    // Simulate database update
    await new Promise(resolve => setTimeout(resolve, 50));
  }

  private async linkMemoryAnchorToGovernanceEvents(anchor: any): Promise<void> {
    console.log(`üîó Linking memory anchor ${anchor.id} to governance events`);
    // Simulate database update
    await new Promise(resolve => setTimeout(resolve, 50));
  }

  // Public API

  async getResource(uri: string): Promise<MCPResource | null> {
    return this.resources.get(uri) || null;
  }

  async listResources(): Promise<MCPResource[]> {
    return Array.from(this.resources.values());
  }

  async executeTool(toolName: string, args: any): Promise<any> {
    const tool = this.tools.get(toolName);
    if (!tool) {
      throw new Error(`Tool not found: ${toolName}`);
    }

    try {
      return await tool.handler(args);
    } catch (error) {
      console.error(`Tool execution failed: ${toolName}`, error);
      throw error;
    }
  }

  async healthCheck(): Promise<{
    status: 'healthy' | 'degraded' | 'unhealthy';
    checks: Record<string, boolean>;
    compliance: string;
    database: string;
  }> {
    const checks = {
      initialized: this.initialized,
      databaseConnected: this.connectionPool?.connected || false,
      azureIdentityReady: await azureIdentityService.healthCheck().then(h => h.status === 'healthy'),
      auCompliant: this.connectionPool?.auCompliant || false,
      resourcesRegistered: this.resources.size > 0,
      toolsRegistered: this.tools.size > 0
    };

    const healthyChecks = Object.values(checks).filter(Boolean).length;
    let status: 'healthy' | 'degraded' | 'unhealthy';

    if (healthyChecks === Object.keys(checks).length) {
      status = 'healthy';
    } else if (healthyChecks >= 4) {
      status = 'degraded';
    } else {
      status = 'unhealthy';
    }

    return {
      status,
      checks,
      compliance: 'AU-compliant',
      database: this.config?.database?.database || 'unknown'
    };
  }
}

// Export singleton instance
export const mcpMSSQLServer = new MCPMSSQLServer();
export default mcpMSSQLServer;